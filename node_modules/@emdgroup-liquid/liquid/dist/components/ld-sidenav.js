import { HTMLElement, createEvent, h, Host, proxyCustomElement } from '@stencil/core/internal/client';
import { g as getClassNames } from './getClassNames.js';
import { d as defineCustomElement$5 } from './ld-icon2.js';
import { d as defineCustomElement$4 } from './ld-sidenav-scroller-internal2.js';
import { d as defineCustomElement$3 } from './ld-sidenav-separator2.js';
import { d as defineCustomElement$2 } from './ld-sr-only2.js';

const getFirstFocusable = (el) => {
  const focusableSelector = [
    '.hydrated',
    'a[href]',
    'area[href]',
    'input:not([type="hidden"]):not([type="radio"]):not(:disabled)',
    'input[type="radio"]:not(:disabled)',
    'select:not(:disabled)',
    'textarea:not(:disabled)',
    'button:not(:disabled)',
    'iframe',
    'audio[controls]',
    'video[controls]',
    '[contenteditable]',
    '[tabindex]',
  ]
    .map((selector) => selector + ':not([tabindex^="-"])')
    .join(',');
  const focusableElements = [
    el,
    ...Array.from(el.querySelectorAll(focusableSelector)),
  ];
  return focusableElements.find((el) => {
    return (!el.classList.contains('hydrated') ||
      Array.from(el.shadowRoot.querySelectorAll(focusableSelector)).find(getFirstFocusable));
  });
};

const ldSidenavCss = ":host{--ld-sidenav-closable-min-width:20rem;--ld-sidenav-padding-x:1rem;--ld-sidenav-padding-y:1rem;--ld-sidenav-padding:var(--ld-sidenav-padding-y) var(--ld-sidenav-padding-x);--ld-sidenav-toggle-size:var(--ld-sp-24);--ld-sidenav-toggle-top:calc(var(--ld-sidenav-padding-y)*2 + var(--ld-sidenav-navitem-icon-size) - var(--ld-sidenav-toggle-size)*0.5);--ld-sidenav-translate-x-delta:calc(var(--ld-sidenav-width) - var(--ld-sidenav-width-collapsed));--ld-sidenav-width:15.625rem;--ld-sidenav-width-collapsed:calc(var(--ld-sidenav-padding-x)*2 + var(--ld-sidenav-navitem-icon-size));--ld-sidenav-width-fully-collapsed:1rem;--ld-sidenav-navitem-icon-size:var(--ld-sp-32);--ld-sidenav-transition-duration:0.001s;--ld-sidenav-transition-duration-collapse-expand:0.001s;--ld-sidenav-transition-delay:0s;--ld-sidenav-transition-delay-collapse-expand:0s;--ld-sidenav-translate-x-direction:1;--ld-sidenav-bg-color:var(--ld-col-wht);--ld-sidenav-subnav-bg-color:var(--ld-thm-primary-alpha-lowest)}@media (prefers-reduced-motion:no-preference){:host(.ld-sidenav--initialized){--ld-sidenav-transition-duration:0.2s;--ld-sidenav-transition-duration-collapse-expand:0.2s;--ld-sidenav-transition-delay:0.1s;--ld-sidenav-transition-delay-collapse-expand:0.1s}}@media (prefers-reduced-motion:no-preference){:host(.ld-sidenav--toggle-transition-disabled){--ld-sidenav-transition-duration-collapse-expand:0.001s;--ld-sidenav-transition-delay-collapse-expand:0s}}:host(.ld-sidenav--neutral){--ld-sidenav-subnav-bg-color:var(--ld-col-neutral-050)}:host{position:var(--ld-sidenav-position,fixed);top:0;bottom:0;left:0;width:var(--ld-sidenav-width);background-color:var(--ld-sidenav-bg-color);box-sizing:border-box;text-align:left;z-index:0}:host:before{content:\"\";position:absolute;top:0;bottom:0;right:0;width:var(--ld-sp-1);background-color:var(--ld-col-neutral-100);transform:translateX(50%) scaleX(1.5);z-index:1}:host(.ld-sidenav--transitions){transition:transform var(--ld-sidenav-transition-duration-collapse-expand) ease}:host(.ld-sidenav--transitions) .ld-sidenav__content{transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear}:host(.ld-sidenav--transitions.ld-sidenav--closable:not(.ld-sidenav--open)) .ld-sidenav__content{transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear,visibility 0s var(--ld-sidenav-transition-duration-collapse-expand) linear;visibility:hidden}:host(.ld-sidenav--collapsed:not(.ld-sidenav--closable)){transform:translateX(calc(var(--ld-sidenav-translate-x-direction)*(-100% + var(--ld-sidenav-width-collapsed))))}:host(.ld-sidenav--collapsed.ld-sidenav--fully-collapsible:not(.ld-sidenav--closable)){transform:translateX(calc(var(--ld-sidenav-translate-x-direction)*(-100% + var(--ld-sidenav-width-fully-collapsed))))}:host(.ld-sidenav--collapsed.ld-sidenav--fully-collapsible:not(.ld-sidenav--closable)) .ld-sidenav__content{opacity:0;visibility:hidden}:host(.ld-sidenav--collapsed.ld-sidenav--fully-collapsible.ld-sidenav--transitions:not(.ld-sidenav--closable)) .ld-sidenav__content{transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear,visibility 0s var(--ld-sidenav-transition-duration-collapse-expand) linear}:host(.ld-sidenav--right){--ld-sidenav-translate-x-direction:-1;--ld-sidenav-translate-x-delta:0;left:unset;right:0}:host(.ld-sidenav--right):before{right:unset;left:0;transform:translateX(-50%) scaleX(1.5)}:host(.ld-sidenav--closable){width:100%;min-width:var(--ld-sidenav-closable-min-width);transform:translateX(calc(var(--ld-sidenav-translate-x-direction)*-100%))}:host(.ld-sidenav--closable.ld-sidenav--open){transform:translateX(0)}:host ::slotted(ld-sidenav-navitem:last-of-type){margin-bottom:var(--ld-sidenav-padding-y)}:host ::slotted(ld-sidenav-navitem){margin:var(--ld-sidenav-padding-y) 0 0}.ld-sidenav__toggle{aspect-ratio:1;background-color:var(--ld-col-wht);border:0;border-radius:var(--ld-br-full);box-shadow:var(--ld-shadow-stacked);color:var(--ld-thm-primary);cursor:pointer;display:grid;align-content:center;justify-content:center;place-content:center;position:absolute;right:0;top:var(--ld-sidenav-toggle-top);touch-action:manipulation;transform:translateX(50%);width:var(--ld-sidenav-toggle-size);will-change:transform;z-index:1;-webkit-touch-callout:none}.ld-sidenav__toggle:after{content:\"\";position:absolute;top:calc(var(--ld-sp-6)*-1);right:calc(var(--ld-sp-6)*-1);bottom:calc(var(--ld-sp-6)*-1);left:calc(var(--ld-sp-6)*-1);display:block;border-radius:inherit}.ld-sidenav__toggle:focus:focus-visible:not(:active),.ld-sidenav__toggle:hover:not(:active){box-shadow:var(--ld-shadow-sticky)}.ld-sidenav__toggle:where(:focus:focus-visible){color:var(--ld-thm-primary-focus)}@media (hover:hover){.ld-sidenav__toggle:where(:hover){color:var(--ld-thm-primary-hover)}}.ld-sidenav__toggle:where(:active),.ld-sidenav__toggle:where(:active:focus-visible){color:var(--ld-thm-primary-active)}:host(.ld-sidenav--right) .ld-sidenav__toggle{transform:translateX(-50%);right:unset;left:0}.ld-sidenav__toggle-icon{transform-origin:center}:host(.ld-sidenav--collapsed) .ld-sidenav__toggle-icon,:host(.ld-sidenav--right) .ld-sidenav__toggle-icon{transform:rotate(180deg)}:host(.ld-sidenav--right.ld-sidenav--collapsed) .ld-sidenav__toggle-icon{transform:none}.ld-sidenav__content{display:flex;flex-direction:column;height:100%;overflow:hidden;will-change:transform}.ld-sidenav__slot-container-default{height:100%;position:relative}.ld-sidenav__slot-container-bottom,.ld-sidenav__slot-container-top{background-color:var(--ld-sidenav-bg-color);z-index:1;position:relative}.ld-sidenav__slot-container-bottom:before,.ld-sidenav__slot-container-default:before,.ld-sidenav__slot-container-top:before{visibility:visible;z-index:0;opacity:0;content:\"\";position:absolute;top:0;right:0;bottom:0;left:0;background-color:var(--ld-sidenav-subnav-bg-color);transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear}:host(.ld-sidenav--has-active-subnav) .ld-sidenav__slot-container-bottom:before,:host(.ld-sidenav--has-active-subnav) .ld-sidenav__slot-container-default:before,:host(.ld-sidenav--has-active-subnav) .ld-sidenav__slot-container-top:before{opacity:1}";

let LdSidenav$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ldSidenavCollapsedChange = createEvent(this, "ldSidenavCollapsedChange", 7);
    this.ldSidenavOpenChange = createEvent(this, "ldSidenavOpenChange", 7);
    this.ldSidenavBreakpointChange = createEvent(this, "ldSidenavBreakpointChange", 7);
    /** Whether the nav should be aligned to the left or the right side of its container. */
    this.align = 'left';
    /**
     * The breakpoint at which the sidenav takes full width and can be
     * opened and closed as opposed to being expanded and collapsed.
     * The prop value is used in a max-width media query.
     */
    this.breakpoint = '23.4375rem';
    /** Indicates that the navigation is collapsed to the side of its container. */
    this.collapsed = false;
    /**
     * Makes the navigation collapse either on
     * - explicit toggle button click,
     * - when the user clicks somewhere outside the element or
     * - when the user moves the cursor / focus outside the element.
     * The modes are inclusive from right to left:
     * - clickoutside applies if the collapse trigger is set to mouseout
     * - toggle applies if the collapse trigger is set to clickoutside
     */
    this.collapseTrigger = 'toggle';
    /**
     * Allows the side navigation to be collapsed to the side of its container.
     */
    this.collapsible = false;
    /**
     * Makes the navigation expand either on
     * - explicit toggle button click,
     * - when the user moves the cursor over the element.
     * The modes are inclusive from right to left:
     * - toggle applies if the expand trigger is set to mouseenter
     */
    this.expandTrigger = 'toggle';
    /** Label to be used for the landmark element (the sidenav itself). */
    this.label = 'Side navigation';
    /** Label to be used for the toggle button when navigation is expanded. */
    this.labelCollapse = 'Collapse side navigation';
    /** Label to be used for the toggle button when navigation is collapsed. */
    this.labelExpand = 'Expand side navigation';
    /**
     * Set to true if you'd like to have a sidenav which partially
     * collapses in way, that slotted ld-navitem components are displayed
     * as icon buttons.
     */
    this.narrow = false;
    /**
     * Set to true if the subnav should use a neutral background color
     * instead of theme colors.
     */
    this.neutral = false;
    /**
     * Indicates that the navigation is visible in a viewport
     * which is smaller than the value of the `breakpoint` prop.
     */
    this.open = false;
    /**
     * Disables transitions on collapsing and expansion of the sidenav.
     * This is especially usefull when the page content gets pushed to
     * the side on sidenav expansion, and you want to prevent too many
     * layout shifts during the transition.
     */
    this.toggleTransitionDisabled = false;
    this.fullyCollapsible = false;
    this.hasActiveSubnav = false;
    this.hasShadowBottom = false;
    this.hasShadowTop = false;
    this.initialized = false;
    this.toFocus = undefined;
    this.focusTimeout = undefined;
    this.updateFocus = () => {
      // HACK: Using recursive call with timeout to account for fast user interactions during transitions.
      clearTimeout(this.focusTimeout);
      if (this.toFocus) {
        if (this.toFocus.tabIndex === -1 ||
          window.getComputedStyle(this.toFocus).visibility === 'hidden') {
          this.focusTimeout = setTimeout(this.updateFocus, 10);
          return;
        }
        this.toFocus.focus();
        this.toFocus = undefined;
      }
    };
    this.toggleCollapsedState = () => {
      this.collapsed = !this.collapsed;
    };
    this.onMatchMediaChange = (ev) => {
      this.closable = ev.matches;
      if (this.closable) {
        this.el.classList.remove('ld-sidenav--transitions');
      }
      this.ldSidenavBreakpointChange.emit(this.closable);
    };
  }
  onCollapsedChange(collapsed) {
    // Apply transitions class explicitly on collapsed state change
    // in order to prevent transitions when closable state changes to false
    // which may happen on screen resize or orientation change events.
    if (!this.closable) {
      this.el.classList.add('ld-sidenav--transitions');
      this.ldSidenavCollapsedChange.emit(collapsed);
    }
  }
  onOpenChange(open) {
    // Same applies here as for onCollapsedChange.
    this.el.classList.add('ld-sidenav--transitions');
    this.ldSidenavOpenChange.emit(open);
  }
  handleClickOutside(ev) {
    if (['clickoutside', 'mouseout'].includes(this.collapseTrigger) &&
      ev.target.closest('ld-sidenav') !== this.el) {
      this.collapsed = this.collapsible;
    }
  }
  handleMouseOut(ev) {
    if (this.collapseTrigger === 'mouseout' &&
      ev.relatedTarget &&
      ev.relatedTarget.closest('ld-sidenav') !== this.el) {
      this.collapsed = this.collapsible;
    }
  }
  handleMouseIn() {
    if (this.expandTrigger === 'mouseenter') {
      this.collapsed = false;
    }
  }
  handleOpen() {
    this.open = true;
  }
  handleClose() {
    clearTimeout(this.focusTimeout);
    this.open = false;
  }
  handleSlideBack() {
    clearTimeout(this.focusTimeout);
    const currentSubnav = Array.from(this.el.querySelectorAll('.ld-sidenav-subnav--active')).pop();
    const currentSubnavId = currentSubnav === null || currentSubnav === void 0 ? void 0 : currentSubnav.id;
    const parentSubnav = currentSubnav === null || currentSubnav === void 0 ? void 0 : currentSubnav.parentElement;
    this.el.querySelector('ld-sidenav-slider').navigateBack();
    // Set focus on parent nav-item element as soon as back button looses focus.
    this.toFocus = parentSubnav === null || parentSubnav === void 0 ? void 0 : parentSubnav.querySelector(`[to='${currentSubnavId}']`).shadowRoot.querySelector('[part*="focusable"]');
  }
  slideToHandler() {
    var _a;
    clearTimeout(this.focusTimeout);
    // set focus on back button
    const ldSidenavBack = (_a = this.el
      .querySelector('ld-sidenav-back')) === null || _a === void 0 ? void 0 : _a.shadowRoot.querySelector('.ld-sidenav-back');
    this.toFocus = ldSidenavBack;
    this.updateFocus();
  }
  slideChangeHandler(ev) {
    var _a, _b;
    clearTimeout(this.focusTimeout);
    (_a = this.el.querySelector('ld-sidenav-back')) === null || _a === void 0 ? void 0 : _a.updateLabel((_b = ev.detail) === null || _b === void 0 ? void 0 : _b.label);
    // Check if current subnav is fully collapsable.
    this.hasActiveSubnav = !!ev.detail;
    const activeSubnav = ev.detail
      ? document.getElementById(ev.detail.id)
      : this.el.querySelector('ld-sidenav-slider');
    const activeSubnavContainsIcons = !!Array.from(activeSubnav.querySelectorAll('ld-sidenav-navitem')).find(({ mode }) => !mode);
    this.fullyCollapsible = !this.narrow || !activeSubnavContainsIcons;
    // Always expand sidebar on slide change, except for
    // when the sidebar is initially loaded.
    if (this.initialized) {
      this.collapsed = false;
    }
    this.updateFocus();
  }
  handleKeyDown(ev) {
    // Ignore events if sidenav has no focus and is not closable.
    const hasSidenavFocus = document.activeElement.closest('ld-sidenav') === this.el;
    if (hasSidenavFocus &&
      ev.key === 'Tab' &&
      !ev.shiftKey &&
      document.activeElement === this.el.querySelector('ld-sidenav-back')) {
      // This block prevents the focus from being set to the wrong element,
      // when a user quickly hits the [Tab] key after triggering the
      // transition to a subnav.
      const { currentSubnav } = this.el.querySelector('ld-sidenav-slider');
      if (currentSubnav) {
        const firstItemOfCurrentSubnav = getFirstFocusable(this.el.querySelector(`#${currentSubnav}`));
        setTimeout(async () => {
          if ('focusInner' in firstItemOfCurrentSubnav) {
            await firstItemOfCurrentSubnav.focusInner();
          }
          else {
            firstItemOfCurrentSubnav.focus();
          }
        });
      }
    }
    if (!hasSidenavFocus && !this.closable) {
      return;
    }
    const slider = this.el.querySelector('ld-sidenav-slider');
    if (ev.key === 'Escape') {
      if (!slider && this.closable) {
        this.open = false;
        return;
      }
      if (this.hasActiveSubnav) {
        this.handleSlideBack();
      }
      else if (this.closable) {
        this.open = false;
      }
    }
  }
  async handleFocusout(ev) {
    const relatedTarget = ev.relatedTarget;
    const isFocusInSidenav = (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.closest('ld-sidenav')) === this.el;
    // If focus is outside the sidenav and the collapse trigger is set
    // to 'mouseout', collapse the sidenav.
    if (!isFocusInSidenav && relatedTarget !== null) {
      if (this.collapseTrigger === 'mouseout') {
        this.collapsed = this.collapsible;
      }
    }
    // If focus is inside the sidenav expand the sidenav.
    if (isFocusInSidenav) {
      this.collapsed = false;
    }
    // If the sidenav is closable, trap the focus.
    // Do not trap the focus as long as the sidenav is not closable or not open.
    if (!this.closable || !this.open)
      return;
    // Do not trap the focus if the trap focus prop is not set.
    if (this.trapFocus === undefined)
      return;
    // Do not trap the focus as long as the focus remains within the sidenav.
    if (isFocusInSidenav)
      return;
    // Do not trap the focus when it moves to an element which matches
    // the trap focus selector or no element will be focused.
    const isFocusInKeepFocusable = this.trapFocus !== '' &&
      (!relatedTarget || (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.matches(this.trapFocus)));
    if (isFocusInKeepFocusable)
      return;
    // Loop the focus between the ld-sidenav and the elements matching
    // the trap focus selector.
    const target = ev.target;
    const isLeavingSidenav = target.closest('ld-sidenav') === this.el;
    const isLeavingFocusSelectorElement = this.trapFocus !== '' && !!target.closest(this.trapFocus);
    if (!isLeavingSidenav && !isLeavingFocusSelectorElement)
      return;
    const firstFocusableInSidenav = getFirstFocusable(this.el);
    const trapFocusSelectorElements = this.trapFocus === ''
      ? [firstFocusableInSidenav]
      : Array.from(document.querySelectorAll(this.trapFocus));
    const firstFocusableFromSelectorElements = trapFocusSelectorElements.find(getFirstFocusable);
    const isLeavingFirstFocusableInSidenav = firstFocusableInSidenav === target;
    const isLeavingFirstFocusableFromSelectorElements = firstFocusableFromSelectorElements === target;
    const lastFocusableInSidenav = Array.from(this.el.querySelectorAll('*'))
      .reverse()
      .find(getFirstFocusable);
    const lastFocusableFromSelectorElements = trapFocusSelectorElements
      .reverse()
      .find(getFirstFocusable);
    const nextFocused = isLeavingSidenav
      ? isLeavingFirstFocusableInSidenav
        ? lastFocusableFromSelectorElements
        : firstFocusableFromSelectorElements
      : isLeavingFirstFocusableFromSelectorElements
        ? lastFocusableInSidenav
        : firstFocusableInSidenav;
    if (!nextFocused)
      return;
    if ('focusInner' in nextFocused) {
      await nextFocused.focusInner();
    }
    else {
      nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.focus();
    }
  }
  componentWillLoad() {
    this.mediaQuery = window.matchMedia(`(max-width: ${this.breakpoint})`);
    this.mediaQuery.addEventListener('change', this.onMatchMediaChange);
    this.closable = this.mediaQuery.matches;
    this.fullyCollapsible =
      !this.narrow || !this.el.querySelector('ld-sidenav-slider');
  }
  componentDidLoad() {
    this.ldSidenavCollapsedChange.emit(this.collapsible && this.collapsed);
    this.ldSidenavOpenChange.emit(this.open);
    this.ldSidenavBreakpointChange.emit(this.closable);
    setTimeout(() => {
      this.initialized = true;
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.mediaQuery) === null || _a === void 0 ? void 0 : _a.removeEventListener('change', this.onMatchMediaChange);
  }
  render() {
    const cl = [
      'ld-sidenav',
      this.align === 'right' && 'ld-sidenav--right',
      this.initialized && 'ld-sidenav--initialized',
      this.closable && 'ld-sidenav--closable',
      this.collapsible && this.collapsed && 'ld-sidenav--collapsed',
      this.collapsible && 'ld-sidenav--collapsible',
      this.fullyCollapsible && 'ld-sidenav--fully-collapsible',
      this.hasActiveSubnav && 'ld-sidenav--has-active-subnav',
      this.hasShadowTop && 'ld-sidenav--has-shadow-top',
      this.hasShadowBottom && 'ld-sidenav--has-shadow-bottom',
      this.neutral && 'ld-sidenav--neutral',
      this.open && 'ld-sidenav--open',
      this.toggleTransitionDisabled && 'ld-sidenav--toggle-transition-disabled',
    ];
    return (h(Host, { class: getClassNames(cl), role: "navigation", "aria-label": this.label }, !this.closable && this.collapsible && (h("button", { role: "switch", "brand-color": true, "aria-checked": this.collapsed ? 'false' : 'true', class: "ld-sidenav__toggle", onClick: this.toggleCollapsedState, part: "toggle" }, h("ld-icon", { part: "toggle-icon", size: "sm", name: "arrow-left", class: "ld-sidenav__toggle-icon" }), h("ld-sr-only", null, this.collapsed ? this.labelExpand : this.labelCollapse))), h("div", { class: "ld-sidenav__content" }, h("div", { class: "ld-sidenav__slot-container-top", part: "slot-container-top" }, h("slot", { name: "top" })), h("ld-sidenav-scroller-internal", { class: "ld-sidenav__scroller", part: "scroll-container" }, h("div", { class: "ld-sidenav__slot-container-default", part: "slot-container" }, h("slot", null))), h("div", { class: "ld-sidenav__slot-container-bottom", part: "slot-container-bottom" }, h("slot", { name: "bottom" })))));
  }
  get el() { return this; }
  static get watchers() { return {
    "collapsed": ["onCollapsedChange"],
    "open": ["onOpenChange"]
  }; }
  static get style() { return ldSidenavCss; }
};
LdSidenav$1 = /*@__PURE__*/ proxyCustomElement(LdSidenav$1, [1, "ld-sidenav", {
    "align": [1],
    "breakpoint": [1],
    "collapsed": [1028],
    "collapseTrigger": [1, "collapse-trigger"],
    "collapsible": [4],
    "expandTrigger": [1, "expand-trigger"],
    "label": [1],
    "labelCollapse": [1, "label-collapse"],
    "labelExpand": [1, "label-expand"],
    "narrow": [4],
    "neutral": [4],
    "open": [1028],
    "toggleTransitionDisabled": [4, "toggle-transition-disabled"],
    "trapFocus": [1, "trap-focus"],
    "closable": [32],
    "fullyCollapsible": [32],
    "hasActiveSubnav": [32],
    "hasShadowBottom": [32],
    "hasShadowTop": [32],
    "initialized": [32]
  }, [[8, "click", "handleClickOutside"], [1, "mouseout", "handleMouseOut"], [1, "mouseenter", "handleMouseIn"], [0, "ldSidenavOpen", "handleOpen"], [0, "ldSidenavClose", "handleClose"], [0, "ldSidenavBack", "handleSlideBack"], [0, "ldSidenavNavitemTo", "slideToHandler"], [0, "ldSidenavSliderChange", "slideChangeHandler"], [9, "keydown", "handleKeyDown"], [9, "focusout", "handleFocusout"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ld-sidenav", "ld-icon", "ld-sidenav-scroller-internal", "ld-sidenav-separator", "ld-sr-only"];
  components.forEach(tagName => { switch (tagName) {
    case "ld-sidenav":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, LdSidenav$1);
      }
      break;
    case "ld-icon":
      if (!customElements.get(tagName)) {
        defineCustomElement$5();
      }
      break;
    case "ld-sidenav-scroller-internal":
      if (!customElements.get(tagName)) {
        defineCustomElement$4();
      }
      break;
    case "ld-sidenav-separator":
      if (!customElements.get(tagName)) {
        defineCustomElement$3();
      }
      break;
    case "ld-sr-only":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}
defineCustomElement$1();

const LdSidenav = LdSidenav$1;
const defineCustomElement = defineCustomElement$1;

export { LdSidenav, defineCustomElement };
