import { HTMLElement, createEvent, h, Host, proxyCustomElement } from '@stencil/core/internal/client';
import { g as getClassNames } from './getClassNames.js';
import { c as closest } from './closest.js';
import { d as defineCustomElement$3 } from './ld-sidenav-scroller-internal2.js';
import { d as defineCustomElement$2 } from './ld-sidenav-separator2.js';

const ldSidenavSliderCss = ":host{transition:transform var(--ld-sidenav-transition-duration) ease;display:block;height:100%;width:100%;position:absolute}:host.ld-sidenav-slider--subnav-active{visibility:hidden}:host ::slotted(:where(:not(ld-sidenav-separator):not(ld-sidenav-navitem):not(ld-sidenav-subnav))){margin-top:var(--ld-sidenav-padding-y);transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) var(--ld-sidenav-transition-delay-collapse-expand) linear,transform var(--ld-sidenav-transition-duration-collapse-expand) ease;will-change:opacity,transform}:host ::slotted(.ld-sidenav-slider__hidden){transition:opacity var(--ld-sidenav-transition-duration-collapse-expand) linear,visibility 0s var(--ld-sidenav-transition-duration-collapse-expand) linear,transform var(--ld-sidenav-transition-duration-collapse-expand) ease;opacity:0;visibility:hidden;transform:translateX(var(--ld-sidenav-translate-x-delta))}";

let LdSidenavSlider$1 = class extends HTMLElement {
  constructor() {
    super();
    this.__registerHost();
    this.__attachShadow();
    this.ldSidenavSliderChange = createEvent(this, "ldSidenavSliderChange", 7);
    this.activeSubnavs = [];
    this.isFirstLevelHidden = false;
    this.updateActiveBeforeTransition = () => {
      // reset
      this.el.querySelectorAll('ld-sidenav-subnav').forEach((subnav) => {
        subnav.activeBeforeTransition = false;
      });
      // update
      this.activeSubnavs.forEach((subnav) => {
        subnav.activeBeforeTransition = true;
      });
    };
    this.updateActive = () => {
      // reset
      this.el.querySelectorAll('ld-sidenav-subnav').forEach((subnav) => {
        subnav.active = false;
      });
      // update
      this.activeSubnavs.forEach((subnav) => {
        subnav.active = true;
      });
    };
    this.updateAncestor = () => {
      // reset
      this.el.querySelectorAll('ld-sidenav-subnav').forEach((subnav) => {
        subnav.ancestor = false;
      });
      // update
      this.activeSubnavs.forEach((subnav, index) => {
        subnav.ancestor = index < this.activeSubnavs.length - 1;
      });
    };
    this.updateFirstLevelHidden = () => {
      this.isFirstLevelHidden = this.currentNavLevel > 0;
    };
    this.scrollInactiveToTop = () => {
      // Scroll all inactive subnav scroll containers to top.
      Array.from(this.el.querySelectorAll('ld-sidenav-subnav')).forEach((subnav) => {
        if (!subnav.active) {
          subnav.scrollToTop();
        }
      });
    };
    this.onTransitionEnd = (event) => {
      if (event.target !== this.el)
        return;
      this.updateActive();
      this.updateAncestor();
      this.updateFirstLevelHidden();
      this.scrollInactiveToTop();
    };
    this.toggleVisibilityOnHidableContent = (visible) => {
      Array.from(this.el.children).forEach((el) => {
        // To also hide one of the following elements,
        // it is possible to wrap it in a div with display contents.
        if (![
          'LD-SIDENAV-SEPARATOR',
          'LD-SIDENAV-NAVITEM',
          'LD-SIDENAV-SUBNAV',
        ].includes(el.tagName)) {
          el.classList.toggle('ld-sidenav-slider__hidden', !visible);
        }
      });
    };
  }
  navigateToSubnav() {
    // Make current subnav and all ancestor subnavs active.
    let parentSubnav;
    let subnavId = this.currentSubnav;
    this.activeSubnavs = [];
    while (subnavId) {
      const subnav = document.querySelector(`#${subnavId}`);
      if (subnav) {
        subnav.active = true;
        parentSubnav = subnav.closest(`ld-sidenav-subnav:not(#${subnavId})`);
        this.activeSubnavs.unshift(subnav);
        if (parentSubnav) {
          subnavId = parentSubnav.id;
        }
        else {
          subnavId = undefined;
        }
      }
      else {
        subnavId = undefined;
      }
    }
    if (this.activeSubnavs.length !== this.currentNavLevel) {
      // Condition is true for almost all use cases.
      let needsInertUpdate = false;
      if (this.currentNavLevel === undefined ||
        this.currentNavLevel > this.activeSubnavs.length) {
        needsInertUpdate = true;
        this.updateAncestor();
      }
      this.currentNavLevel = this.activeSubnavs.length;
      if (needsInertUpdate)
        this.updateFirstLevelHidden();
      this.updateActiveBeforeTransition();
    }
    else if (this.activeSubnavs.length > 0) {
      // This condition applies if navigating to a subnav
      // which has the same level as the currently active subnav.
      // This happens on change of the currentSubnav prop from
      // the outside.
      this.updateActive();
      this.updateAncestor();
      this.updateFirstLevelHidden();
      this.scrollInactiveToTop();
    }
  }
  handleSubnavChange() {
    this.navigateToSubnav();
    this.emitChange();
  }
  slideToHandler(ev) {
    this.currentSubnav = ev.detail.id;
  }
  handleSidenavCollapsedChange(ev) {
    if (ev.target !== this.sidenav)
      return;
    if (ev.detail) {
      this.scrollerRef.scrollToTop(true);
      this.toggleVisibilityOnHidableContent(false);
    }
    else {
      this.toggleVisibilityOnHidableContent(true);
    }
  }
  /** Navigates back to the parent nav. */
  async navigateBack() {
    if (this.currentNavLevel > 0) {
      const parentSubnav = this.activeSubnavs[this.activeSubnavs.length - 2];
      this.currentSubnav = (parentSubnav === null || parentSubnav === void 0 ? void 0 : parentSubnav.id) || '';
    }
  }
  emitChange() {
    const activeSubnav = this.activeSubnavs[this.activeSubnavs.length - 1];
    if (activeSubnav) {
      const parentSubnav = this.activeSubnavs[this.activeSubnavs.length - 2] || this.el;
      this.ldSidenavSliderChange.emit({
        id: activeSubnav.id,
        label: parentSubnav.label,
      });
    }
    else if (!this.currentSubnav) {
      this.ldSidenavSliderChange.emit();
    }
  }
  componentWillLoad() {
    this.sidenav = closest('ld-sidenav', this.el);
    if (this.currentSubnav) {
      this.handleSubnavChange();
    }
    if (this.currentNavLevel === undefined) {
      this.currentNavLevel = 0;
    }
  }
  render() {
    const cl = getClassNames([
      'ld-sidenav-slider',
      this.currentNavLevel > 0 && 'ld-sidenav-slider--subnav-active',
    ]);
    return (h(Host, { onTransitionEnd: this.onTransitionEnd, class: cl, style: {
        transform: `translateX(-${this.currentNavLevel}00%)`,
        visibility: this.isFirstLevelHidden ? 'hidden' : 'inherit',
      } }, h("ld-sidenav-scroller-internal", { part: "scroll-container", ref: (el) => (this.scrollerRef = el) }, h("slot", null))));
  }
  get el() { return this; }
  static get watchers() { return {
    "currentSubnav": ["handleSubnavChange"]
  }; }
  static get style() { return ldSidenavSliderCss; }
};
LdSidenavSlider$1 = /*@__PURE__*/ proxyCustomElement(LdSidenavSlider$1, [1, "ld-sidenav-slider", {
    "currentSubnav": [1025, "current-subnav"],
    "label": [1],
    "currentNavLevel": [32],
    "activeSubnavs": [32],
    "isFirstLevelHidden": [32],
    "navigateBack": [64]
  }, [[0, "ldSidenavNavitemTo", "slideToHandler"], [9, "ldSidenavCollapsedChange", "handleSidenavCollapsedChange"]]]);
function defineCustomElement$1() {
  if (typeof customElements === "undefined") {
    return;
  }
  const components = ["ld-sidenav-slider", "ld-sidenav-scroller-internal", "ld-sidenav-separator"];
  components.forEach(tagName => { switch (tagName) {
    case "ld-sidenav-slider":
      if (!customElements.get(tagName)) {
        customElements.define(tagName, LdSidenavSlider$1);
      }
      break;
    case "ld-sidenav-scroller-internal":
      if (!customElements.get(tagName)) {
        defineCustomElement$3();
      }
      break;
    case "ld-sidenav-separator":
      if (!customElements.get(tagName)) {
        defineCustomElement$2();
      }
      break;
  } });
}
defineCustomElement$1();

const LdSidenavSlider = LdSidenavSlider$1;
const defineCustomElement = defineCustomElement$1;

export { LdSidenavSlider, defineCustomElement };
