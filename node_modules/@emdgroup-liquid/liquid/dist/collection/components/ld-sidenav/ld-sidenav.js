import '../../components'; // type definitions for type checks and intelliSense
import { Component, Element, Event, h, Host, Listen, Prop, State, Watch, } from '@stencil/core';
import { getClassNames } from '../../utils/getClassNames';
import { getFirstFocusable } from '../../utils/focus';
/**
 * @slot - default slot, vertically scrollable.
 * @slot top - slot fixed at the top, above scrollable default slot.
 * @slot bottom - slot fixed at the bottom, below scrollable default slot.
 * @virtualProp ref - reference to component
 * @virtualProp {string | number} key - for tracking the node's identity when working with lists
 */
export class LdSidenav {
  constructor() {
    /** Whether the nav should be aligned to the left or the right side of its container. */
    this.align = 'left';
    /**
     * The breakpoint at which the sidenav takes full width and can be
     * opened and closed as opposed to being expanded and collapsed.
     * The prop value is used in a max-width media query.
     */
    this.breakpoint = '23.4375rem';
    /** Indicates that the navigation is collapsed to the side of its container. */
    this.collapsed = false;
    /**
     * Makes the navigation collapse either on
     * - explicit toggle button click,
     * - when the user clicks somewhere outside the element or
     * - when the user moves the cursor / focus outside the element.
     * The modes are inclusive from right to left:
     * - clickoutside applies if the collapse trigger is set to mouseout
     * - toggle applies if the collapse trigger is set to clickoutside
     */
    this.collapseTrigger = 'toggle';
    /**
     * Allows the side navigation to be collapsed to the side of its container.
     */
    this.collapsible = false;
    /**
     * Makes the navigation expand either on
     * - explicit toggle button click,
     * - when the user moves the cursor over the element.
     * The modes are inclusive from right to left:
     * - toggle applies if the expand trigger is set to mouseenter
     */
    this.expandTrigger = 'toggle';
    /** Label to be used for the landmark element (the sidenav itself). */
    this.label = 'Side navigation';
    /** Label to be used for the toggle button when navigation is expanded. */
    this.labelCollapse = 'Collapse side navigation';
    /** Label to be used for the toggle button when navigation is collapsed. */
    this.labelExpand = 'Expand side navigation';
    /**
     * Set to true if you'd like to have a sidenav which partially
     * collapses in way, that slotted ld-navitem components are displayed
     * as icon buttons.
     */
    this.narrow = false;
    /**
     * Set to true if the subnav should use a neutral background color
     * instead of theme colors.
     */
    this.neutral = false;
    /**
     * Indicates that the navigation is visible in a viewport
     * which is smaller than the value of the `breakpoint` prop.
     */
    this.open = false;
    /**
     * Disables transitions on collapsing and expansion of the sidenav.
     * This is especially usefull when the page content gets pushed to
     * the side on sidenav expansion, and you want to prevent too many
     * layout shifts during the transition.
     */
    this.toggleTransitionDisabled = false;
    this.fullyCollapsible = false;
    this.hasActiveSubnav = false;
    this.hasShadowBottom = false;
    this.hasShadowTop = false;
    this.initialized = false;
    this.toFocus = undefined;
    this.focusTimeout = undefined;
    this.updateFocus = () => {
      // HACK: Using recursive call with timeout to account for fast user interactions during transitions.
      clearTimeout(this.focusTimeout);
      if (this.toFocus) {
        if (this.toFocus.tabIndex === -1 ||
          window.getComputedStyle(this.toFocus).visibility === 'hidden') {
          this.focusTimeout = setTimeout(this.updateFocus, 10);
          return;
        }
        this.toFocus.focus();
        this.toFocus = undefined;
      }
    };
    this.toggleCollapsedState = () => {
      this.collapsed = !this.collapsed;
    };
    this.onMatchMediaChange = (ev) => {
      this.closable = ev.matches;
      if (this.closable) {
        this.el.classList.remove('ld-sidenav--transitions');
      }
      this.ldSidenavBreakpointChange.emit(this.closable);
    };
  }
  onCollapsedChange(collapsed) {
    // Apply transitions class explicitly on collapsed state change
    // in order to prevent transitions when closable state changes to false
    // which may happen on screen resize or orientation change events.
    if (!this.closable) {
      this.el.classList.add('ld-sidenav--transitions');
      this.ldSidenavCollapsedChange.emit(collapsed);
    }
  }
  onOpenChange(open) {
    // Same applies here as for onCollapsedChange.
    this.el.classList.add('ld-sidenav--transitions');
    this.ldSidenavOpenChange.emit(open);
  }
  handleClickOutside(ev) {
    if (['clickoutside', 'mouseout'].includes(this.collapseTrigger) &&
      ev.target.closest('ld-sidenav') !== this.el) {
      this.collapsed = this.collapsible;
    }
  }
  handleMouseOut(ev) {
    if (this.collapseTrigger === 'mouseout' &&
      ev.relatedTarget &&
      ev.relatedTarget.closest('ld-sidenav') !== this.el) {
      this.collapsed = this.collapsible;
    }
  }
  handleMouseIn() {
    if (this.expandTrigger === 'mouseenter') {
      this.collapsed = false;
    }
  }
  handleOpen() {
    this.open = true;
  }
  handleClose() {
    clearTimeout(this.focusTimeout);
    this.open = false;
  }
  handleSlideBack() {
    clearTimeout(this.focusTimeout);
    const currentSubnav = Array.from(this.el.querySelectorAll('.ld-sidenav-subnav--active')).pop();
    const currentSubnavId = currentSubnav === null || currentSubnav === void 0 ? void 0 : currentSubnav.id;
    const parentSubnav = currentSubnav === null || currentSubnav === void 0 ? void 0 : currentSubnav.parentElement;
    this.el.querySelector('ld-sidenav-slider').navigateBack();
    // Set focus on parent nav-item element as soon as back button looses focus.
    this.toFocus = parentSubnav === null || parentSubnav === void 0 ? void 0 : parentSubnav.querySelector(`[to='${currentSubnavId}']`).shadowRoot.querySelector('[part*="focusable"]');
  }
  slideToHandler() {
    var _a;
    clearTimeout(this.focusTimeout);
    // set focus on back button
    const ldSidenavBack = (_a = this.el
      .querySelector('ld-sidenav-back')) === null || _a === void 0 ? void 0 : _a.shadowRoot.querySelector('.ld-sidenav-back');
    this.toFocus = ldSidenavBack;
    this.updateFocus();
  }
  slideChangeHandler(ev) {
    var _a, _b;
    clearTimeout(this.focusTimeout);
    (_a = this.el.querySelector('ld-sidenav-back')) === null || _a === void 0 ? void 0 : _a.updateLabel((_b = ev.detail) === null || _b === void 0 ? void 0 : _b.label);
    // Check if current subnav is fully collapsable.
    this.hasActiveSubnav = !!ev.detail;
    const activeSubnav = ev.detail
      ? document.getElementById(ev.detail.id)
      : this.el.querySelector('ld-sidenav-slider');
    const activeSubnavContainsIcons = !!Array.from(activeSubnav.querySelectorAll('ld-sidenav-navitem')).find(({ mode }) => !mode);
    this.fullyCollapsible = !this.narrow || !activeSubnavContainsIcons;
    // Always expand sidebar on slide change, except for
    // when the sidebar is initially loaded.
    if (this.initialized) {
      this.collapsed = false;
    }
    this.updateFocus();
  }
  handleKeyDown(ev) {
    // Ignore events if sidenav has no focus and is not closable.
    const hasSidenavFocus = document.activeElement.closest('ld-sidenav') === this.el;
    if (hasSidenavFocus &&
      ev.key === 'Tab' &&
      !ev.shiftKey &&
      document.activeElement === this.el.querySelector('ld-sidenav-back')) {
      // This block prevents the focus from being set to the wrong element,
      // when a user quickly hits the [Tab] key after triggering the
      // transition to a subnav.
      const { currentSubnav } = this.el.querySelector('ld-sidenav-slider');
      if (currentSubnav) {
        const firstItemOfCurrentSubnav = getFirstFocusable(this.el.querySelector(`#${currentSubnav}`));
        setTimeout(async () => {
          if ('focusInner' in firstItemOfCurrentSubnav) {
            await firstItemOfCurrentSubnav.focusInner();
          }
          else {
            firstItemOfCurrentSubnav.focus();
          }
        });
      }
    }
    if (!hasSidenavFocus && !this.closable) {
      return;
    }
    const slider = this.el.querySelector('ld-sidenav-slider');
    if (ev.key === 'Escape') {
      if (!slider && this.closable) {
        this.open = false;
        return;
      }
      if (this.hasActiveSubnav) {
        this.handleSlideBack();
      }
      else if (this.closable) {
        this.open = false;
      }
    }
  }
  async handleFocusout(ev) {
    const relatedTarget = ev.relatedTarget;
    const isFocusInSidenav = (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.closest('ld-sidenav')) === this.el;
    // If focus is outside the sidenav and the collapse trigger is set
    // to 'mouseout', collapse the sidenav.
    if (!isFocusInSidenav && relatedTarget !== null) {
      if (this.collapseTrigger === 'mouseout') {
        this.collapsed = this.collapsible;
      }
    }
    // If focus is inside the sidenav expand the sidenav.
    if (isFocusInSidenav) {
      this.collapsed = false;
    }
    // If the sidenav is closable, trap the focus.
    // Do not trap the focus as long as the sidenav is not closable or not open.
    if (!this.closable || !this.open)
      return;
    // Do not trap the focus if the trap focus prop is not set.
    if (this.trapFocus === undefined)
      return;
    // Do not trap the focus as long as the focus remains within the sidenav.
    if (isFocusInSidenav)
      return;
    // Do not trap the focus when it moves to an element which matches
    // the trap focus selector or no element will be focused.
    const isFocusInKeepFocusable = this.trapFocus !== '' &&
      (!relatedTarget || (relatedTarget === null || relatedTarget === void 0 ? void 0 : relatedTarget.matches(this.trapFocus)));
    if (isFocusInKeepFocusable)
      return;
    // Loop the focus between the ld-sidenav and the elements matching
    // the trap focus selector.
    const target = ev.target;
    const isLeavingSidenav = target.closest('ld-sidenav') === this.el;
    const isLeavingFocusSelectorElement = this.trapFocus !== '' && !!target.closest(this.trapFocus);
    if (!isLeavingSidenav && !isLeavingFocusSelectorElement)
      return;
    const firstFocusableInSidenav = getFirstFocusable(this.el);
    const trapFocusSelectorElements = this.trapFocus === ''
      ? [firstFocusableInSidenav]
      : Array.from(document.querySelectorAll(this.trapFocus));
    const firstFocusableFromSelectorElements = trapFocusSelectorElements.find(getFirstFocusable);
    const isLeavingFirstFocusableInSidenav = firstFocusableInSidenav === target;
    const isLeavingFirstFocusableFromSelectorElements = firstFocusableFromSelectorElements === target;
    const lastFocusableInSidenav = Array.from(this.el.querySelectorAll('*'))
      .reverse()
      .find(getFirstFocusable);
    const lastFocusableFromSelectorElements = trapFocusSelectorElements
      .reverse()
      .find(getFirstFocusable);
    const nextFocused = isLeavingSidenav
      ? isLeavingFirstFocusableInSidenav
        ? lastFocusableFromSelectorElements
        : firstFocusableFromSelectorElements
      : isLeavingFirstFocusableFromSelectorElements
        ? lastFocusableInSidenav
        : firstFocusableInSidenav;
    if (!nextFocused)
      return;
    if ('focusInner' in nextFocused) {
      await nextFocused.focusInner();
    }
    else {
      nextFocused === null || nextFocused === void 0 ? void 0 : nextFocused.focus();
    }
  }
  componentWillLoad() {
    this.mediaQuery = window.matchMedia(`(max-width: ${this.breakpoint})`);
    this.mediaQuery.addEventListener('change', this.onMatchMediaChange);
    this.closable = this.mediaQuery.matches;
    this.fullyCollapsible =
      !this.narrow || !this.el.querySelector('ld-sidenav-slider');
  }
  componentDidLoad() {
    this.ldSidenavCollapsedChange.emit(this.collapsible && this.collapsed);
    this.ldSidenavOpenChange.emit(this.open);
    this.ldSidenavBreakpointChange.emit(this.closable);
    setTimeout(() => {
      this.initialized = true;
    });
  }
  disconnectedCallback() {
    var _a;
    (_a = this.mediaQuery) === null || _a === void 0 ? void 0 : _a.removeEventListener('change', this.onMatchMediaChange);
  }
  render() {
    const cl = [
      'ld-sidenav',
      this.align === 'right' && 'ld-sidenav--right',
      this.initialized && 'ld-sidenav--initialized',
      this.closable && 'ld-sidenav--closable',
      this.collapsible && this.collapsed && 'ld-sidenav--collapsed',
      this.collapsible && 'ld-sidenav--collapsible',
      this.fullyCollapsible && 'ld-sidenav--fully-collapsible',
      this.hasActiveSubnav && 'ld-sidenav--has-active-subnav',
      this.hasShadowTop && 'ld-sidenav--has-shadow-top',
      this.hasShadowBottom && 'ld-sidenav--has-shadow-bottom',
      this.neutral && 'ld-sidenav--neutral',
      this.open && 'ld-sidenav--open',
      this.toggleTransitionDisabled && 'ld-sidenav--toggle-transition-disabled',
    ];
    return (h(Host, { class: getClassNames(cl), role: "navigation", "aria-label": this.label },
      !this.closable && this.collapsible && (h("button", { role: "switch", "brand-color": true, "aria-checked": this.collapsed ? 'false' : 'true', class: "ld-sidenav__toggle", onClick: this.toggleCollapsedState, part: "toggle" },
        h("ld-icon", { part: "toggle-icon", size: "sm", name: "arrow-left", class: "ld-sidenav__toggle-icon" }),
        h("ld-sr-only", null, this.collapsed ? this.labelExpand : this.labelCollapse))),
      h("div", { class: "ld-sidenav__content" },
        h("div", { class: "ld-sidenav__slot-container-top", part: "slot-container-top" },
          h("slot", { name: "top" })),
        h("ld-sidenav-scroller-internal", { class: "ld-sidenav__scroller", part: "scroll-container" },
          h("div", { class: "ld-sidenav__slot-container-default", part: "slot-container" },
            h("slot", null))),
        h("div", { class: "ld-sidenav__slot-container-bottom", part: "slot-container-bottom" },
          h("slot", { name: "bottom" })))));
  }
  static get is() { return "ld-sidenav"; }
  static get encapsulation() { return "shadow"; }
  static get originalStyleUrls() { return {
    "$": ["ld-sidenav.css"]
  }; }
  static get styleUrls() { return {
    "$": ["ld-sidenav.css"]
  }; }
  static get properties() { return {
    "align": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'left' | 'right'",
        "resolved": "\"left\" | \"right\"",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Whether the nav should be aligned to the left or the right side of its container."
      },
      "attribute": "align",
      "reflect": false,
      "defaultValue": "'left'"
    },
    "breakpoint": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "The breakpoint at which the sidenav takes full width and can be\nopened and closed as opposed to being expanded and collapsed.\nThe prop value is used in a max-width media query."
      },
      "attribute": "breakpoint",
      "reflect": false,
      "defaultValue": "'23.4375rem'"
    },
    "collapsed": {
      "type": "boolean",
      "mutable": true,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Indicates that the navigation is collapsed to the side of its container."
      },
      "attribute": "collapsed",
      "reflect": false,
      "defaultValue": "false"
    },
    "collapseTrigger": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'toggle' | 'clickoutside' | 'mouseout'",
        "resolved": "\"clickoutside\" | \"mouseout\" | \"toggle\"",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Makes the navigation collapse either on\n- explicit toggle button click,\n- when the user clicks somewhere outside the element or\n- when the user moves the cursor / focus outside the element.\nThe modes are inclusive from right to left:\n- clickoutside applies if the collapse trigger is set to mouseout\n- toggle applies if the collapse trigger is set to clickoutside"
      },
      "attribute": "collapse-trigger",
      "reflect": false,
      "defaultValue": "'toggle'"
    },
    "collapsible": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Allows the side navigation to be collapsed to the side of its container."
      },
      "attribute": "collapsible",
      "reflect": false,
      "defaultValue": "false"
    },
    "expandTrigger": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "'toggle' | 'mouseenter'",
        "resolved": "\"mouseenter\" | \"toggle\"",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Makes the navigation expand either on\n- explicit toggle button click,\n- when the user moves the cursor over the element.\nThe modes are inclusive from right to left:\n- toggle applies if the expand trigger is set to mouseenter"
      },
      "attribute": "expand-trigger",
      "reflect": false,
      "defaultValue": "'toggle'"
    },
    "label": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Label to be used for the landmark element (the sidenav itself)."
      },
      "attribute": "label",
      "reflect": false,
      "defaultValue": "'Side navigation'"
    },
    "labelCollapse": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Label to be used for the toggle button when navigation is expanded."
      },
      "attribute": "label-collapse",
      "reflect": false,
      "defaultValue": "'Collapse side navigation'"
    },
    "labelExpand": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Label to be used for the toggle button when navigation is collapsed."
      },
      "attribute": "label-expand",
      "reflect": false,
      "defaultValue": "'Expand side navigation'"
    },
    "narrow": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Set to true if you'd like to have a sidenav which partially\ncollapses in way, that slotted ld-navitem components are displayed\nas icon buttons."
      },
      "attribute": "narrow",
      "reflect": false,
      "defaultValue": "false"
    },
    "neutral": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Set to true if the subnav should use a neutral background color\ninstead of theme colors."
      },
      "attribute": "neutral",
      "reflect": false,
      "defaultValue": "false"
    },
    "open": {
      "type": "boolean",
      "mutable": true,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Indicates that the navigation is visible in a viewport\nwhich is smaller than the value of the `breakpoint` prop."
      },
      "attribute": "open",
      "reflect": false,
      "defaultValue": "false"
    },
    "toggleTransitionDisabled": {
      "type": "boolean",
      "mutable": false,
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      },
      "required": false,
      "optional": false,
      "docs": {
        "tags": [],
        "text": "Disables transitions on collapsing and expansion of the sidenav.\nThis is especially usefull when the page content gets pushed to\nthe side on sidenav expansion, and you want to prevent too many\nlayout shifts during the transition."
      },
      "attribute": "toggle-transition-disabled",
      "reflect": false,
      "defaultValue": "false"
    },
    "trapFocus": {
      "type": "string",
      "mutable": false,
      "complexType": {
        "original": "string",
        "resolved": "string",
        "references": {}
      },
      "required": false,
      "optional": true,
      "docs": {
        "tags": [],
        "text": "Enables focus trapping. Accespts a CSS selector which indicates\nwhat is still focusable outside the sidenav, when the sidenav is\nclosable and open (i.e. \"ld-header *\"). Use an empty string to\nenable focus trapping without specifying focusable elements\noutside the sidenav component."
      },
      "attribute": "trap-focus",
      "reflect": false
    }
  }; }
  static get states() { return {
    "closable": {},
    "fullyCollapsible": {},
    "hasActiveSubnav": {},
    "hasShadowBottom": {},
    "hasShadowTop": {},
    "initialized": {}
  }; }
  static get events() { return [{
      "method": "ldSidenavCollapsedChange",
      "name": "ldSidenavCollapsedChange",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted when the sidenav collapses or expands."
      },
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      }
    }, {
      "method": "ldSidenavOpenChange",
      "name": "ldSidenavOpenChange",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted when the sidenav opens or closes."
      },
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      }
    }, {
      "method": "ldSidenavBreakpointChange",
      "name": "ldSidenavBreakpointChange",
      "bubbles": true,
      "cancelable": true,
      "composed": true,
      "docs": {
        "tags": [],
        "text": "Emitted when the sidenav registers a match media change event."
      },
      "complexType": {
        "original": "boolean",
        "resolved": "boolean",
        "references": {}
      }
    }]; }
  static get elementRef() { return "el"; }
  static get watchers() { return [{
      "propName": "collapsed",
      "methodName": "onCollapsedChange"
    }, {
      "propName": "open",
      "methodName": "onOpenChange"
    }]; }
  static get listeners() { return [{
      "name": "click",
      "method": "handleClickOutside",
      "target": "window",
      "capture": false,
      "passive": false
    }, {
      "name": "mouseout",
      "method": "handleMouseOut",
      "target": undefined,
      "capture": false,
      "passive": true
    }, {
      "name": "mouseenter",
      "method": "handleMouseIn",
      "target": undefined,
      "capture": false,
      "passive": true
    }, {
      "name": "ldSidenavOpen",
      "method": "handleOpen",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "ldSidenavClose",
      "method": "handleClose",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "ldSidenavBack",
      "method": "handleSlideBack",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "ldSidenavNavitemTo",
      "method": "slideToHandler",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "ldSidenavSliderChange",
      "method": "slideChangeHandler",
      "target": undefined,
      "capture": false,
      "passive": false
    }, {
      "name": "keydown",
      "method": "handleKeyDown",
      "target": "window",
      "capture": false,
      "passive": true
    }, {
      "name": "focusout",
      "method": "handleFocusout",
      "target": "window",
      "capture": false,
      "passive": true
    }]; }
}
